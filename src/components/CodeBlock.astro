---
interface Props {
  code: string;
  filename?: string;
}

const { code, filename = 'expression.jsx' } = Astro.props;

// Escape HTML for display
const escapeHtml = (text: string) =>
  text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');

// Escape code for safe HTML attribute embedding (for copy button)
function escapeHtmlAttr(str: string): string {
  return str
    .replace(/&/g, '&amp;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');
}

const escapedCode = escapeHtmlAttr(code);

const applyTokenColors = (text: string) =>
  text
    .replace(/(["'`].*?["'`])/g, '<span class="token string">$1</span>')
    .replace(/\b(-?\d+(?:\.\d+)?)\b/g, '<span class="token number">$1</span>')
    .replace(
      /\b(const|let|var|return|if|else|for|while|function|new|this|true|false|null|undefined)\b/g,
      '<span class="token keyword">$1</span>'
    )
    .replace(/\b([A-Za-z_]\w*)(?=\s*\()/g, '<span class="token function">$1</span>');

const findCommentIndex = (line: string) => {
  let inString: string | null = null;
  let escapedChar = false;

  for (let i = 0; i < line.length; i += 1) {
    const char = line[i];

    if (escapedChar) {
      escapedChar = false;
      continue;
    }

    if (char === '\\') {
      escapedChar = true;
      continue;
    }

    if (!inString && char === '/' && line[i + 1] === '/') {
      return i;
    }

    if (char === '"' || char === "'" || char === '`') {
      inString = inString === char ? null : char;
    }
  }

  return -1;
};

const highlightLine = (line: string) => {
  const commentIndex = findCommentIndex(line);

  if (commentIndex !== -1) {
    const codePart = line.slice(0, commentIndex);
    const commentPart = line.slice(commentIndex);

    return `${applyTokenColors(escapeHtml(codePart))}<span class="token comment">${escapeHtml(
      commentPart
    )}</span>`;
  }

  return applyTokenColors(escapeHtml(line));
};

const highlightedLines = code
  .trim()
  .split('\n')
  .map((line) => highlightLine(line));
---

<div class="code-section">
  <div class="code-header">
    <span class="code-filename">{filename}</span>
    <div class="code-actions">
      <button class="code-wrap-toggle" type="button">Wrap lines: Off</button>
      <button class="code-copy-btn" data-code={escapedCode} type="button">ðŸ“‹ Copy</button>
    </div>
  </div>

  <div class="code-block" data-wrap="false">
    <pre><code>{highlightedLines.map((line) => (
      <span class="code-line" set:html={line}></span>
    ))}</code></pre>
  </div>
</div>

<script>
  // Track pending timers per button to prevent race conditions
  const pendingTimers = new WeakMap<Element, number>();
  
  // Decode HTML entities back to original code
  function decodeHtmlAttr(str: string): string {
    const textarea = document.createElement('textarea');
    textarea.innerHTML = str;
    return textarea.value;
  }

  const codeSections = document.querySelectorAll('.code-section');

  codeSections.forEach((section) => {
    const copyButton = section.querySelector('.code-copy-btn');
    const wrapButton = section.querySelector('.code-wrap-toggle');
    const codeBlock = section.querySelector('.code-block');

    if (copyButton) {
      copyButton.addEventListener('click', async () => {
        // Cancel any pending timer for this button
        const existingTimer = pendingTimers.get(copyButton);
        if (existingTimer) {
          clearTimeout(existingTimer);
        }

        const encodedCode = copyButton.getAttribute('data-code') || '';
        const code = decodeHtmlAttr(encodedCode);

        try {
          await navigator.clipboard.writeText(code);
          copyButton.textContent = 'âœ“ Copied';
          copyButton.classList.add('copied');
          const timer = window.setTimeout(() => {
            copyButton.textContent = 'ðŸ“‹ Copy';
            copyButton.classList.remove('copied');
            pendingTimers.delete(copyButton);
          }, 2000);
          pendingTimers.set(copyButton, timer);
        } catch (err) {
          copyButton.textContent = 'âŒ Failed';
          copyButton.classList.remove('copied');
          const timer = window.setTimeout(() => {
            copyButton.textContent = 'ðŸ“‹ Copy';
            pendingTimers.delete(copyButton);
          }, 2000);
          pendingTimers.set(copyButton, timer);
        }
      });
    }

    if (wrapButton && codeBlock) {
      let isWrapped = false;

      const updateWrapState = () => {
        codeBlock.classList.toggle('wrap-lines', isWrapped);
        codeBlock.setAttribute('data-wrap', String(isWrapped));
        wrapButton.textContent = isWrapped ? 'Wrap lines: On' : 'Wrap lines: Off';
        wrapButton.setAttribute('aria-pressed', String(isWrapped));
      };

      wrapButton.addEventListener('click', () => {
        isWrapped = !isWrapped;
        updateWrapState();
      });

      updateWrapState();
    }
  });
</script>
